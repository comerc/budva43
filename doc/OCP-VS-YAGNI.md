# OCP против YAGNI

В этой статье я хочу рассмотреть тему OCP против YAGNI - противоречия между принципом открытости/закрытости и принципом "Тебе это не понадобится".

## OCP

Начнем с напоминания о том, что такое OCP. Принцип открытости/закрытости гласит:

**Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.**

Впервые он был представлен Бертраном Мейером в его канонической книге "Объектно-ориентированное конструирование программного обеспечения". Позже он был популяризирован Бобом Мартином, когда тот представил принципы SOLID.

Официальное определение довольно расплывчато и не очень помогает понять суть. Поэтому давайте углубимся в этот принцип.

В настоящее время существует две интерпретации: Бертрана Мейера и Боба Мартина.

**Интерпретация Боба Мартина** сводится к избеганию эффекта домино. То есть когда вы изменяете часть кода, это не должно требовать внесения изменений по всей кодовой базе для адаптации к этой модификации. В идеале вы должны иметь возможность добавлять новую функциональность без изменения уже существующего кода. Принцип советует закрыть исходный модуль (класс, метод и т.д.) для модификации и вместо этого открыть в нем точку расширения. Эта точка расширения позволит вам вводить новую функциональность без изменения существующей кодовой базы.

Обычно это реализуется с помощью полиморфизма. Например, следующий пример нарушает версию OCP Боба Мартина:

```csharp
public void Draw(Shape shape) 
{
    switch (shape.Type)
    {
        case ShapeType.Circle:
            DrawCircle(shape);
            break;
        case ShapeType.Square:
            DrawSquare(shape);
            break;
        default:
            throw new ArgumentOutOfRangeException();
    }
}
```

Здесь для введения новой фигуры вам потребуется изменить метод Draw. Можно сказать, что добавление новой фигуры распространится по существующей кодовой базе в том смысле, что потребует изменения приведенного выше switch-оператора.

Чтобы исправить это, можно создать абстрактный класс Shape и затем перенести логику рисования в его подклассы:

```csharp
public abstract class Shape 
{
    public abstract void Draw();
}

public class Circle : Shape 
{
    public override void Draw()
    {
        /* … */
    }
}

/* и т.д. */
```

Теперь, если нужно добавить новую фигуру, вы просто создаете подкласс и переопределяете метод Draw. Используя терминологию OCP, вы закрыли класс Shape для модификации и открыли в нем точку расширения. Эта точка расширения может использоваться для создания новой функциональности без изменения существующего кода.

**Первоначальное намерение Бертрана Мейера** за этим принципом отличается. В то время как интерпретация Боба Мартина направлена на уменьшение количества изменений, Бертран Мейер говорит об обратной совместимости.

Когда есть несколько взаимозависимых модулей, каждый из которых разрабатывается отдельной командой программистов, нужно следовать определенному процессу, чтобы это работало. Вы не можете просто изменять свой модуль как угодно и когда угодно, нужно учитывать его клиентов.

Например, если у вас есть библиотека, которая предоставляет метод `CreateCustomer(string email)`, вы не можете внезапно добавить новый обязательный параметр вот так:
`CreateCustomer(string email, string bankAccountNumber)`

Это было бы критическим изменением для клиентского кода, который уже привязан к исходной версии метода.

По сути, это проблема, которую Бертран Мейер пытался решить с помощью принципа OCP. Во время разработки ваш модуль открыт для модификации, поскольку никто еще не привязан к нему. Но как только вы его публикуете, вы должны финализировать, закрыть его API, чтобы он всегда оставался совместимым с существующими клиентами. Если вам нужно внести изменение после публикации, вы делаете это, создавая новый модуль.

Обратите внимание, что Бертран Мейер говорит конкретно об API, а не о фактической реализации модуля. Вы все еще можете изменять реализацию, при условии, что это не изменяет API модуля. Другими словами, исправления ошибок и некритические изменения допустимы, но изменение сигнатур методов и требование новых предусловий - нет.

Вот полный список того, что составляет API:
- **Сигнатура метода**: имя, параметры, возвращаемое значение
- **Предусловия**: список требований, которые клиенты должны выполнить перед использованием метода
- **Постусловия**: список гарантий, которые дает модуль
- **Инварианты**: список условий, которые должны выполняться всегда

Изменение сигнатуры метода, усиление предусловий, ослабление постусловий или изменение инвариантов приведет к критическим изменениям.

Единственный тип совместимости, который был актуален во времена Мейера, - это бинарная совместимость. То есть когда у вас есть две библиотеки и одна из них должна использовать вторую без перекомпиляции и без критических изменений. Однако это все еще применимо в наши дни.

Вся тема версионирования Web API - это, по сути, принцип OCP Мейера, примененный к крупномасштабным проектам. Если у вас есть Микросервис 1, который зависит от Микросервиса 2, вы не можете внести критическое изменение в Микросервис 2, его API должен быть закрыт для таких модификаций. Но вы все еще можете создать новую версию и предоставить существующим клиентам выбор: остаться со старой версией или перейти на новую.

Важно отметить, что версия OCP Мейера имеет смысл только в контексте нескольких команд разработчиков, когда каждый модуль разрабатывается разными командами. В типичной корпоративной среде разработки ПО, где вы являетесь одновременно автором и клиентом кода, который пишете, нет необходимости придерживаться таких сложных практик.

## YAGNI

YAGNI означает "Тебе это не понадобится" и в основном означает, что вы не должны тратить время на функциональность, которая не нужна прямо сейчас. Вы не должны разрабатывать эту функциональность и не должны изменять существующий код, чтобы учесть ее появление в будущем. Вот два основных момента, объясняющих, почему это хорошая идея:

1. **Бизнес-требования постоянно меняются.** Если вы тратите время на функцию, которая не нужна бизнесу в данный момент, вы крадете время у функций, которые им действительно нужны сейчас.

2. **Ваш код - это не актив, а обязательство.** Предпочтительнее иметь меньше кода, а не больше, поскольку любой дополнительный код увеличивает стоимость обслуживания.

Есть ли ситуации, когда YAGNI неприменим? Да, есть.

Вы можете нарушить YAGNI, если проектируете функциональность, которую трудно изменить в будущем. Это клиентские API, сторонние библиотеки, фундаментальные архитектурные решения, пользовательские интерфейсы. В таких ситуациях стоит потратить время на попытку предсказать, как будущая функциональность будет сочетаться с решениями, которые вы принимаете сейчас.

## OCP против YAGNI

Обратите внимание, что YAGNI касается не только реализации неиспользуемой функциональности как таковой, но также запрещает изменение существующей функциональности для учета возможных новых функций в будущем. И именно здесь кроется противоречие. Это "учет возможных новых функций в будущем" - именно то, что предлагает версия OCP Боба Мартина.

Давайте снова посмотрим на метод Draw:

```csharp
public void Draw(Shape shape) 
{
    switch (shape.Type)
    {
        case ShapeType.Circle:
            DrawCircle(shape);
            break;
        case ShapeType.Square:
            DrawSquare(shape);
            break;
        default:
            throw new ArgumentOutOfRangeException();
    }
}
```

С одной стороны, у нас есть YAGNI, который говорит, что этот switch-оператор в порядке, пока результирующий код прост и понятен для понимания и поддержки. С другой стороны, у нас есть OCP Боба Мартина, который говорит, что мы должны иметь возможность расширять его без изменения исходного кода.

Какой из них имеет более высокий приоритет?

Чтобы ответить на этот вопрос, давайте сделаем шаг назад. Обратите внимание, что я говорю о противоречии между YAGNI и OCP Боба Мартина, а не версией Бертрана Мейера. Это потому, что YAGNI не противоречит последней, они в основном говорят о разных вещах.

Что касается версии Боба Мартина, ее можно рассматривать с двух разных перспектив:
1. Когда вы являетесь одновременно автором и клиентом кода (корпоративная разработка)
2. Когда вам нужно опубликовать код для внешнего использования (NuGet пакет или фреймворк)

**YAGNI побеждает OCP**, когда у вас есть полный контроль над тем, как используется код. Почему? Потому что YAGNI, наряду с KISS, является самым важным принципом в разработке программного обеспечения.

Это также имеет смысл, если внимательнее посмотреть на OCP Боба Мартина. Подумайте об этом. Почему вы должны заранее закладывать точки расширения в свой код, даже если это приведет к чрезмерному усложнению? Действительно ли стоит усилий и дальнейших затрат на обслуживание заменять простой switch-оператор отдельной иерархией классов? Конечно, нет. Гораздо лучше заложить эти точки расширения постфактум, когда у вас уже есть полная картина и когда вы видите, что switch-оператор стал слишком раздутым.

Другая ситуация, когда у вас нет контроля над тем, как используется ваш код. В этом случае YAGNI неприменим, потому что стоимость изменения уже реализованной функциональности слишком высока.

В такой ситуации вам действительно нужно определить потенциальные точки вариации и создать вокруг них интерфейс, который позволит потребителям расширять ваши классы, а не изменять их.

## Заключение

Существует две интерпретации принципа открытости/закрытости:

1. **Оригинальная Бертрана Мейера** касается обратной совместимости. Вам нужно закрыть API вашего модуля/библиотеки/сервиса, если он предназначен для внешнего использования.

2. **Боба Мартина** касается избежания эффекта домино: вам нужно иметь возможность расширять поведение программного обеспечения с минимальными изменениями исходного кода.

**Ключевые выводы:**
- YAGNI противоречит версии OCP Боба Мартина
- Противоречие разрешается, если применять OCP Боба Мартина только когда ваш код используется внешними командами
- **YAGNI побеждает OCP Боба Мартина** при корпоративной разработке ПО
- **OCP Боба Мартина побеждает YAGNI** при разработке сторонних библиотек/фреймворков

---

перевод: https://enterprisecraftsmanship.com/posts/ocp-vs-yagni/