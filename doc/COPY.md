# DeepCopy()

## Ограничения:

### 1. **Ограничения сериализации JSON:**
- **Неэкспортируемые поля:** Приватные поля структур не сериализуются (начинающиеся с маленькой буквы)
- **Каналы и функции:** Поля типа `chan` и `func` игнорируются
- **Циклические ссылки:** Может привести к бесконечной рекурсии или панике
- **Специальные типы:** `unsafe.Pointer` и некоторые системные типы не поддерживаются

### 2. **Интерфейсы:**
- **JSON теги:** Интерфейсы с правильными JSON тегами (например `json:"type"`) копируются корректно
- **Конкретные типы:** Если интерфейс содержит конкретный тип, поддерживающий JSON, копирование работает
- **Полиморфизм:** Может потерять информацию о конкретном типе при копировании интерфейсов

### 3. **Производительность:**
- Медленная операция из-за маршалинга/демаршалинга через JSON
- Выделение памяти для промежуточного буфера байтов
- Использование рефлексии внутри encoding/json

### 4. **Обработка ошибок:**
- При любой ошибке сериализации возвращается ошибка (не паникует)

## Преимущества:

### 1. **Глубокое копирование:**
```go
func DeepCopy[T any](from *T) (*T, error) {
	var err error
	var b []byte
	b, err = json.Marshal(from)
	if err != nil {
		return nil, err
	}
	to := new(T)
	err = json.Unmarshal(b, to)
	if err != nil {
		return nil, err
	}
	return to, nil
}
```

`DeepCopy` создаёт **полную независимую копию** всех вложенных структур, срезов, карт и указателей.

### 2. **Поддержка интерфейсов:**
JSON отлично работает с интерфейсами, которые имеют теги `json:"type"`, как в случае с `client.TextEntityType`.

### 3. **Изоляция данных:**
Как показывает тест, после использования `DeepCopy` изменения в копии не влияют на оригинал:

```go
func TestDeepCopy(t *testing.T) {
	t.Parallel()

	type object struct {
		I int64
		A []string
		M map[string]string
	}
	obj1 := &object{}
	obj1.I = 1
	obj1.A = []string{"a", "b"}
	obj1.M = map[string]string{"a": "b"}
	obj2, err := DeepCopy(obj1)
  require.NoError(t, err)
	assert.Equal(t, obj2.I, int64(1))
	assert.Equal(t, obj2.A, []string{"a", "b"})
	assert.Equal(t, obj2.M, map[string]string{"a": "b"})
	obj2.I = 2
	obj2.A[0] = "c"
	obj2.M["a"] = "c"
	assert.Equal(t, obj1.I, int64(1), "obj1.I не изменился")
	assert.Equal(t, obj1.A, []string{"a", "b"}, "obj1.A не изменился")
	assert.Equal(t, obj1.M, map[string]string{"a": "b"}, "obj1.M не изменился")
}
```

## Рекомендации по использованию:

- **Используйте `DeepCopy`** когда нужно полное клонирование сложных структур с вложенными объектами и интерфейсами
- **JSON теги** обеспечивают корректную сериализацию интерфейсов
- **Убедитесь** что все экспортируемые поля имеют правильные теги
