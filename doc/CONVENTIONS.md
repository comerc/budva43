# Соглашения

Важно помнить, что каждый архитектурный выбор - это компромисс между различными факторами, и в данном случае практичность и скорость разработки могут быть более важными, чем строгое соблюдение всех архитектурных принципов.

## Принцип слабого зацепления и высокой связности (Loose Coupling & High Cohesion)

Проект стремится реализовать фундаментальный принцип качественной архитектуры: **слабое зацепление** (loose coupling) между компонентами при сохранении **высокой связности** (high cohesion) внутри компонентов.

### Слабое зацепление (Loose Coupling)

Зацепление - это степень взаимозависимости между программными модулями, мера того, насколько взаимозависимы разные компоненты системы.

В проекте слабое зацепление достигается следующими способами:
- Использование интерфейсов вместо прямых зависимостей от конкретных реализаций
- Передача зависимостей через конструкторы (Dependency Injection)
- Четкое разделение слоев с односторонними зависимостями
- Использование DTO для передачи данных между слоями вместо прямой передачи сущностей
- Минимизация зацепления по общей области и зацепления по содержимому

Преимущества слабого зацепления:
- Возможность изменять компоненты независимо друг от друга
- Упрощение тестирования (можно тестировать компоненты изолированно)
- Повышение гибкости и адаптивности системы
- Упрощение сопровождения и расширения системы

### Высокая связность (High Cohesion)

Связность - это мера того, насколько функции внутри одного модуля логически связаны и направлены на решение одной задачи.

В проекте высокая связность достигается следующими способами:
- Группировка связанных функций в одном модуле/пакете
- Каждый компонент имеет четкую и единую ответственность (следуя принципу SRP)
- Логическое разделение функциональности по соответствующим слоям
- Структурирование кода по функциональным областям, а не по техническим аспектам

Преимущества высокой связности:
- Код легче понимать, так как он логически организован
- Улучшение переиспользуемости компонентов
- Снижение сложности поддержки и модификации
- Локализация изменений при модификации функциональности

Комбинация слабого зацепления и высокой связности создает архитектуру, где компоненты:
1. Могут легко изменяться независимо друг от друга
2. Внутренне логически организованы и направлены на решение конкретных задач
3. Хорошо тестируются по отдельности
4. Образуют гибкую систему в целом

## Принцип DRY (Don't Repeat Yourself)

1. **Общая логика работы с сообщениями**
    - Применение: выделение общих функций обработки сообщений в отдельные методы
    - Цель: избежание дублирования кода обработки сообщений
    - Пример: общие методы форматирования и обработки сообщений в `MessageService`

2. **Утилиты для работы с BadgerDB**
    - Применение: выделение общих операций с BadgerDB в отдельные функции
    - Цель: централизация логики работы с базой данных
    - Пример: утилиты для чтения/записи в `repo/badger`

3. **Обработка ошибок**
    - Применение: стандартизация создания и обработки ошибок
    - Цель: единый подход к обработке ошибок
    - Пример: централизованные функции создания и логирования ошибок в пакете `errors`

(DRY нужно применять без фанатизма, иногда лучше выполнить copy/paste)

## Принцип KISS (Keep It Simple, Stupid)

1. **Простые и понятные интерфейсы**
    - Применение: минимальные интерфейсы с четкой ответственностью
    - Цель: упрощение интеграции и тестирования компонентов
    - Пример: четкое разделение интерфейсов `MessageService` и `ForwardService`

2. **Простая организация зависимостей**
    - Применение: явная передача зависимостей через конструкторы
    - Цель: понятная и отслеживаемая структура зависимостей
    - Пример: самописный DI без использования сложных фреймворков

3. **Модульная структура**
    - Применение: разделение монолита на небольшие модули с единой ответственностью
    - Цель: упрощение понимания и сопровождения кода
    - Пример: четкое разделение на слои controller, service, repo

4. **Низкая цикломатическая сложность**
    - Применение: стремление к простым функциям с минимальным количеством условных ветвлений
    - Цель: повышение читаемости и тестируемости кода
    - Пример: функции с цикломатической сложностью не более 10-15

5. **Принцип раннего возврата (early return)**
    - Применение: обработка ошибок и граничных случаев в начале функции
    - Цель: уменьшение уровней вложенности и повышение читаемости кода
    - Пример:
    ```go
    // Хороший стиль с ранним возвратом
    func ProcessMessage(msg *Message) error {
        if msg == nil {
            return errors.New("message is nil")
        }
        
        if err := validateMessage(msg); err != nil {
            return fmt.Errorf("invalid message: %w", err)
        }
        
        // Основная логика обработки сообщения
        return nil
    }

    // Плохой стиль с глубокой вложенностью
    func ProcessMessagePoor(msg *Message) error {
        if msg != nil {
            if validateMessage(msg) == nil {
                // Основная логика обработки сообщения
                return nil
            } else {
                return errors.New("invalid message")
            }
        } else {
            return errors.New("message is nil")
        }
    }
    ```

## Принципы SOLID

1. **Принцип единственной ответственности (SRP)**
    - Применение: каждый класс имеет только одну ответственность
    - Цель: упрощение сопровождения и тестирования
    - Пример: разделение логики фильтрации (`FilterService`) и пересылки (`ForwardService`)

2. **Принцип открытости/закрытости (OCP)**
    - Применение: расширение функциональности через добавление новых компонентов, а не изменение существующих
    - Цель: минимизация изменений существующего кода
    - Пример: добавление новых стратегий фильтрации без изменения существующих

3. **Принцип подстановки Барбары Лисков (LSP)**
    - Применение: корректное использование интерфейсов и их реализаций
    - Цель: обеспечение взаимозаменяемости объектов одного типа
    - Пример: все реализации `repo/telegram` должны корректно работать в контексте `service/message`

4. **Принцип разделения интерфейса (ISP)**
    - Применение: минимальные и специализированные интерфейсы
    - Цель: клиенты не должны зависеть от методов, которые они не используют
    - Пример: разделение интерфейса работы с сообщениями на более специализированные интерфейсы

5. **Принцип инверсии зависимостей (DIP)**
    - Применение: зависимость от абстракций, а не от конкретных реализаций
    - Цель: уменьшение связанности между компонентами
    - Пример: сервисы зависят от интерфейсов репозиториев, а не от их конкретных реализаций

## Нотация Start и Run

В проекте будет применяться следующая нотация для инициализации и запуска компонентов:

1. **Метод `New*` или конструктор**
    - Создает экземпляр компонента
    - Инициализирует зависимости и внутреннее состояние
    - Не запускает никаких фоновых задач или горутин
    - Пример: `NewMessageService(repo Repo) *MessageService`

2. **Метод `Start`**
    - Подготавливает компонент к работе
    - Устанавливает соединения, инициализирует ресурсы
    - Может быть блокирующим или не блокирующим, в зависимости от контекста
    - В случае ошибки возвращает ее и останавливает запуск приложения
    - Пример: `Start(ctx context.Context) error`

3. **Метод `Run`**
    - Запускает основной цикл работы компонента (обычно блокирующий)
    - Выполняет основную функциональность компонента
    - Работает до получения сигнала завершения через контекст
    - Пример: `Run(ctx context.Context) error`

4. **Метод `Stop`**
    - Корректно останавливает компонент, освобождает ресурсы
    - Вызывается при graceful shutdown
    - Должен быть идемпотентным (можно вызывать несколько раз без побочных эффектов)
    - Пример: `Stop() error`

Эта нотация обеспечивает единообразный подход к управлению жизненным циклом всех компонентов и упрощает организацию корректного запуска и остановки системы.

## Подход к внедрению зависимостей (DI)

Для организации DI будет использован самописный подход на основе использования стандартных механизмов языка Go (context, defer, функции-конструкторы, обработка ошибок), как описано в [статье Vivid Money](https://github.com/vivid-money/article-golang-di):

```go
// Пример организации DI и жизненного цикла в main.go
func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    errSet := &errors.ErrSet{}

    // Обработка сигналов остановки
    go func() {
        util.AwaitSignal(ctx)
        cancel()
    }()

    // Запуск приложения с обработкой ошибок
    if err := runApp(ctx, errSet); err != nil {
        log.Fatalf("Application error: %v", err)
    }

    // Вывод накопленных ошибок при завершении
    if err := errSet.Error(); err != nil {
        log.Printf("Shutdown errors: %v", err)
    }
}

func runApp(ctx context.Context, errSet *errors.ErrSet) error {
    // Инициализация BadgerDB
    badgerRepo := badger.New()
    if err := badgerRepo.Connect(ctx); err != nil {
        return fmt.Errorf("failed to connect to BadgerDB: %w", err)
    }
    defer util.Shutdown("badgerRepo", errSet, badgerRepo.Close)

    // Инициализация TDLib
    telegramRepo, err := telegramRepo.New()
    if err != nil {
        return fmt.Errorf("failed to create Telegram repo: %w", err)
    }
    defer util.Shutdown("telegramRepo", errSet, telegramRepo.Close)

    // Инициализация сервисов
    messageService := messageService.New(telegramRepo, badgerRepo)
    forwardService := forwardService.New(messageService)
    
    // Запуск HTTP-сервера
    httpServer := httpTransport.NewHTTPServer(messageService)
    if ctx, err = util.Serve(ctx, "httpServer", errSet, httpServer.Serve); err != nil {
        return fmt.Errorf("failed to serve HTTP: %w", err)
    }
    defer util.Shutdown("httpServer", errSet, httpServer.Stop)

    // Ожидание завершения контекста
    <-ctx.Done()
    return ctx.Err()
}
```

## Взаимодействие между слоями

1. **Transport → Controller → Service → Repo**:
    - Транспортные адаптеры вызывают методы соответствующих контроллеров
    - Контроллеры оркестрируют работу сервисов, без собственной бизнес-логики
    - Сервисы содержат всю бизнес-логику и взаимодействуют с репозиториями
    - Репозитории инкапсулируют доступ к данным

2. **Преобразование данных в Entity**:
    - Entity используются для передачи данных между всеми слоями
    - Entity могут содержать методы для преобразования форматов (сериализация/десериализация)

3. **Обработка ошибок**:
    - Каждый слой должен обрабатывать соответствующие ему ошибки
    - Репозитории возвращают специфичные для хранилища ошибки
    - Сервисы оборачивают ошибки репозиториев в доменные ошибки
    - Контроллеры преобразуют доменные ошибки в понятный формат для клиента
    - Транспортный слой преобразует ошибки в соответствующие форматы протокола
    
## Модификация подхода к передаче данных

В связи с отказом от отдельного слоя DTO, функциональность передачи данных перешла к Entity:

1. **Entity как средство передачи данных**:
   - Entity используются для передачи данных между всеми слоями системы
   - Entity могут содержать дополнительные методы для преобразования форматов
   - Entity содержат методы сериализации/десериализации для разных форматов (JSON, протоколы)
2. **Методы преобразования форматов в Entity**:
   - Методы для сериализации (`MarshalJSON`, `ToProto`)
   - Методы для десериализации (`UnmarshalJSON`, `FromProto`)
   - Методы для представления в API (`ToResponse`)
   - Методы для валидации (`Validate`)
3. **Пример взаимодействия слоев через Entity**:
   ```go
   // В контроллере
   func (c *MessageController) GetMessage(ctx context.Context, messageID int64) (*entity.Message, error) {
       // Получаем сообщение через сервис
       message, err := c.messageService.GetMessage(ctx, messageID)
       if err != nil {
           return nil, err
       }
       
       return message, nil
   }
   
   // В HTTP-обработчике
   func (h *HTTPHandler) HandleGetMessage(w http.ResponseWriter, r *http.Request) {
       // Получаем ID из запроса
       id := getIDFromRequest(r)
       
       // Получаем сообщение через контроллер
       message, err := h.messageController.GetMessage(r.Context(), id)
       if err != nil {
           handleError(w, err)
           return
       }
       
       // Используем метод Entity для подготовки ответа
       response := message.ToResponse()
       
       // Отправляем ответ
       sendJSON(w, response)
   }
   ```

## Создание и обработка ошибок

1. **Типы ошибок**:
   - Ошибки домена (`entity/errors.go`)
   - Ошибки сервисов (`service/errors.go`)
   - Ошибки репозиториев (`repo/errors.go`)
   - Общие ошибки (`errors/common.go`) - deprecated
2. **Обертывание ошибок**:
   - Использование `fmt.Errorf("context: %w", err)` для добавления контекста
   - Использование `errors.Is` и `errors.As` для проверки типов ошибок
   - Сохранение стек-трейса с помощью библиотеки `github.com/pkg/errors`
3. **Обработка ошибок в разных слоях**:
   - Репозитории: возвращают специфичные ошибки хранилища
   - Сервисы: преобразуют ошибки репозиториев в доменные ошибки
   - Контроллеры: определяют, как обрабатывать ошибки (повтор, отклонение и т.д.)
   - Транспортный слой: преобразует ошибки в соответствующие HTTP-коды, сообщения и т.д.
4. **Пример обработки ошибок**:
   ```go
   // В репозитории
   func (r *MessageRepo) GetMessage(id int64) (*entity.Message, error) {
       message, err := r.db.Get(id)
       if err != nil {
           if errors.Is(err, badger.ErrKeyNotFound) {
               return nil, repo.ErrMessageNotFound
           }
           return nil, fmt.Errorf("getting message from database: %w", err)
       }
       return message, nil
   }
   
   // В сервисе
   func (s *MessageService) GetMessage(ctx context.Context, id int64) (*entity.Message, error) {
       message, err := s.repo.GetMessage(id)
       if err != nil {
           if errors.Is(err, repo.ErrMessageNotFound) {
               return nil, service.ErrMessageNotFound
           }
           return nil, fmt.Errorf("getting message from repo: %w", err)
       }
       return message, nil
   }
   
   // В HTTP-обработчике
   func handleError(w http.ResponseWriter, err error) {
       switch {
       case errors.Is(err, service.ErrMessageNotFound):
           http.Error(w, "Message not found", http.StatusNotFound)
       case errors.Is(err, service.ErrValidation):
           http.Error(w, err.Error(), http.StatusBadRequest)
       default:
           log.Printf("Unexpected error: %v", err)
           http.Error(w, "Internal server error", http.StatusInternalServerError)
       }
   }
   ```
5. **Форматирование ошибок**:
    - На английском языке
    - С большой буквы
    - Без точки в конце

## Соглашения по интеграции с go-tdlib и созданию структур данных

1. **Минимизация дублирования** - максимально использовать структуры go-tdlib, избегая создания дублирующих структур.
2. **Композиция вместо наследования** - использовать композицию структур go-tdlib в наших сущностях там, где это возможно.
3. **Сущности как простые структуры данных** - сущности (entity) должны содержать только структуры данных, конструкторы и простые геттеры/сеттеры, без сложной бизнес-логики.
4. **Бизнес-логика в сервисном слое** - вся бизнес-логика должна быть в сервисном слое, а не в сущностях.
5. **Интерфейсы для репозиториев** - определять чёткие интерфейсы для репозиториев, следуя идиоме "принимаем интерфейсы, возвращаем конкретные типы".
6. **DTO только при необходимости преобразования** - использовать DTO только когда формат данных должен отличаться от Entity (для API, конфигурации, специальных представлений).

## Использование интерфейсов

Для обеспечения слабой связанности компонентов и возможности тестирования следует использовать интерфейсы:

```go
// Пример интерфейса контроллера
type MessageController interface {
    GetMessage(chatID, messageID int64) (*model.Message, error)
    SendMessage(message *model.Message) (*model.Message, error)
    EditMessage(chatID, messageID int64, text string) (*model.Message, error)
    DeleteMessage(chatID, messageID int64) error
}

// Пример интерфейса сервиса
type MessageService interface {
    GetMessage(chatID, messageID int64) (*entity.Message, error)
    SendMessage(message *entity.Message) (*entity.Message, error)
    EditMessage(chatID, messageID int64, text string) (*entity.Message, error)
    DeleteMessage(chatID, messageID int64) error
}

// Пример интерфейса репозитория
type TelegramRepo interface {
    SendMessage(chatID int64, text string) (*entity.Message, error)
    GetMessage(chatID, messageID int64) (*entity.Message, error)
    DeleteMessage(chatID, messageID int64) error
}
```

### Локальное объявление интерфейсов

Применяется подход с локальным объявлением интерфейсов в тех же файлах, где они используются. Это соответствует принципу "Interface Segregation" (ISP) из SOLID и обеспечивает лучшую обособленность модулей:

```go
// Локальное объявление интерфейса в начале файла (после секции импортов)
type SomeObj interface {
  SomeMethod()
}

type Service struct {
  someObj SomeObj
}

func NewService(someObj SomeObj)* Service {
  return &Service{someObj: someObj}
}

func (s Service) ServiceMethod() {
  s.someObj.SomeMethod()
}
```

Локальные интерфейсы для собственных структур (например, для сервисов) не объявляются, т.к. они не используются по этой схеме.

## Идиома передачи интерфейсов и возврата структур

В проекте будет применяться следующая идиома Go:

**"Принимай интерфейсы, возвращай структуры" (Accept interfaces, return structs)**

Эта идиома предписывает:
- Функции-конструкторы должны принимать параметры с типом интерфейса, а не конкретной структуры
- Функции-конструкторы должны возвращать конкретные типы, а не интерфейсы

```go
// Правильно - принимаем интерфейс, возвращаем структуру
func NewMessageService(repo TelegramRepo) *MessageService {
    return &MessageService{repo: repo}
}

// Неправильно - возвращаем интерфейс вместо структуры
func NewMessageService(repo TelegramRepo) MessageServiceInterface {
    return &MessageService{repo: repo}
}
```

Преимущества этого подхода:
1. **Гибкость** - функции работают с любыми объектами, реализующими необходимый интерфейс
2. **Тестируемость** - можно легко создавать моки для тестирования
3. **Конкретность** - клиенты всегда знают конкретный тип возвращаемого объекта
4. **Отсутствие лишних абстракций** - интерфейсы определяются потребителями, а не производителями

Применение этой идиомы повышает гибкость кода, упрощает тестирование и соответствует принципам Go по работе с интерфейсами.

### Ограничение на применение идиомы только в функциях-констукторах

В Go два интерфейса с одинаковыми методами считаются совместимыми (compatible), но типы функций с разными именованными типами в сигнатуре - нет, даже если эти типы имеют одинаковые интерфейсы.

Например:
```go
type driver1 interface { Method() }
type driver2 interface { Method() }

// Это работает:
var d1 driver1 = someImplementation{}
var d2 driver2 = d1

// А это нет:
type fn1 func(driver1)
type fn2 func(driver2)
var f1 fn1 = func(d driver1) {}
var f2 fn2 = f1 // ошибка компиляции
```

Из-за этого ограничения нельзя использовать передачу интерфейсов в аргументах методов других интерфейсов. Идиома применима только в функциях-констукторах. 

## Соглашение о контроле области видимости переменных

Для предотвращения проблемы скрытого переиспользования переменной `err` и других подобных переменных будет применяться ограничение области видимости с помощью фигурных скобок. Это позволит избежать потенциальных уязвимостей безопасности и логических ошибок.

**Пример правильного использования:**

```go
var v1 V1
{
    v1Tmp, err := NewV1()
    if err != nil {
        log.Error(err)
        return err
    }
    v1 = v1Tmp
}

var v2 V2
{
    v2Tmp, err := NewV2()
    if err != nil {
        log.Error(err)
        return err
    }
    v2 = v2Tmp
}
```

**Или альтернативный вариант:**

```go 
{
    v1, err := NewV1()
    if err != nil {
        log.Error(err)
        return err
    }
    // использование v1
}

{
    v2, err := NewV2()
    if err != nil {
        log.Error(err)
        return err
    }
    // использование v2
}
```

## Соглашения по тестированию

- [testing/synctest experiment for time and concurrency testing](https://danp.net/posts/synctest-experiment/)
- Применяется `assert.AnError` вместо `errors.New("some error")`
- Применяется `t.Parallel()` и флаг для выявления гонки данных
- Применяется AAA (Arange Act Asset), т.е. assert-ы для проверки условий, а request-для проверки сетапа
- Юнит-тесты размещаются в том же пакете, что и тестируемый код, с суффиксом `_test.go`
- Интеграционные тесты размещаются в директории `/test`
- Для каждой функциональной единицы должны быть написаны тесты, покрывающие основные сценарии использования

### Виды юнит-тестов

В проекте будут применяться два основных вида юнит-тестов:

1. **Тесты для покрытия кодовой базы**
    - Цель: обеспечение технического качества кода и предотвращение регрессий
    - Фокус: тестирование отдельных функций и методов, проверка корректности обработки граничных случаев
    - Особенности:
        - Обычно более детализированы и многочисленны
        - Проверяют корректность реализации, а не бизнес-ценность
        - Полезны при рефакторинге для обеспечения сохранения функциональности
    - Пример: тестирование утилитарных функций, методов доступа к данным, преобразований данных

2. **Тесты для покрытия бизнес-логики**
    - Цель: проверка соответствия кода бизнес-требованиям
    - Фокус: тестирование бизнес-сценариев и потоков, проверка правильности бизнес-решений
    - Особенности:
        - Написаны с точки зрения бизнес-требований
        - Охватывают ключевые сценарии использования системы
        - Служат как документация бизнес-процессов
    - Пример: тестирование правил фильтрации сообщений, логики пересылки, генерации отчетов

Оба вида тестов необходимы для обеспечения качества системы, но имеют разные цели и подходы. Первый вид обеспечивает надежность технической реализации, второй – соответствие бизнес-потребностям.

### Реализация

Преимущественно в проекте применяются табличные (table-driven) тесты:
- Каждый тест-кейс определяется как отдельная строка в таблице тестовых данных
- Тесты слабосвязаны - каждый тест является атомарным и не зависит от результатов других тестов
- Одинаковая инициализация и проверка выполнения для всех тестовых случаев
- Улучшенная читаемость и расширяемость - добавление нового тест-кейса требует только добавления строки в таблицу

В частности, предпочтительно используются call-тесты:
- В каждом табличном тесте определены функции для подготовки входных данных и проверки выходных
- Эти функции независимы и атомарны для каждого тест-кейса
- Позволяют сфокусироваться на тестируемом поведении, абстрагируясь от деталей подготовки данных

Пример структуры табличного call-теста:
```go
func TestFormatMessage(t *testing.T) {
    tests := []struct {
        name           string
        // Функции для подготовки входных данных
        setupInput     func() string
        setupMocks     func() *mocks.MockFormatter
        // Ожидаемый результат и функция проверки
        expectedOutput string
        verifyFunc     func(t *testing.T, result string, err error, formatter *mocks.MockFormatter)
    }{
        {
            name: "Успешное форматирование",
            setupInput: func() string {
                return "Исходный текст"
            },
            setupMocks: func() *mocks.MockFormatter {
                formatter := mocks.NewMockFormatter(t)
                formatter.EXPECT().Format(gomock.Any()).Return("Отформатированный текст", nil)
                return formatter
            },
            expectedOutput: "Отформатированный текст",
            verifyFunc: func(t *testing.T, result string, err error, formatter *mocks.MockFormatter) {
                assert.NoError(t, err)
                assert.Equal(t, "Отформатированный текст", result)
            },
        },
        {
            name: "Обработка пустой строки",
            setupInput: func() string {
                return ""
            },
            setupMocks: func() *mocks.MockFormatter {
                formatter := mocks.NewMockFormatter(t)
                formatter.EXPECT().Format(gomock.Any()).Return("", errors.New("empty input"))
                return formatter
            },
            expectedOutput: "",
            verifyFunc: func(t *testing.T, result string, err error, formatter *mocks.MockFormatter) {
                assert.Error(t, err)
                assert.Equal(t, "", result)
                assert.Contains(t, err.Error(), "empty input")
            },
        },
        // другие тест-кейсы
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Атомарная инициализация для каждого тест-кейса
            input := tt.setupInput()
            formatter := tt.setupMocks()
            
            // Выполнение тестируемой функции
            result, err := FormatMessage(input, formatter)
            
            // Проверка результата через функцию проверки
            tt.verifyFunc(t, result, err, formatter)
        })
    }
}
```

Преимущества call-тестов:
1. **Гибкость** - можно легко менять стратегию подготовки данных и проверки результатов
2. **Изоляция** - каждый тест-кейс полностью изолирован и имеет собственный контекст
3. **Читаемость** - лучшая организация кода с фокусом на тестируемом поведении
4. **Расширяемость** - легко добавлять новые тест-кейсы без дублирования кода

