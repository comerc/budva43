# Соглашения

Важно помнить, что каждый архитектурный выбор - это компромисс между различными факторами, и в данном случае практичность и скорость разработки могут быть более важными, чем строгое соблюдение всех архитектурных принципов.

## Communicating Sequential Processes (CSP)

Основной принцип Go в контексте конкурентности выражен фразой:
> "Don't communicate by sharing memory, share memory by communicating"

Это означает, что вместо защиты общей памяти с помощью мьютексов и других примитивов синхронизации, лучше организовать обмен данными через каналы.

## Принцип слабого зацепления и высокой связности (Loose Coupling & High Cohesion)

Проект стремится реализовать фундаментальный принцип качественной архитектуры: **слабое зацепление** (loose coupling) между компонентами при сохранении **высокой связности** (high cohesion) внутри компонентов.

### Слабое зацепление (Loose Coupling)

Зацепление - это степень взаимозависимости между программными модулями, мера того, насколько взаимозависимы разные компоненты системы.

В проекте слабое зацепление достигается следующими способами:
- Использование интерфейсов вместо прямых зависимостей от конкретных реализаций
- Передача зависимостей через конструкторы (Dependency Injection)
- Четкое разделение слоев с односторонними зависимостями
- Использование DTO для передачи данных между слоями вместо прямой передачи сущностей
- Минимизация зацепления по общей области и зацепления по содержимому

Преимущества слабого зацепления:
- Возможность изменять компоненты независимо друг от друга
- Упрощение тестирования (можно тестировать компоненты изолированно)
- Повышение гибкости и адаптивности системы
- Упрощение сопровождения и расширения системы

### Высокая связность (High Cohesion)

Связность - это мера того, насколько функции внутри одного модуля логически связаны и направлены на решение одной задачи.

В проекте высокая связность достигается следующими способами:
- Группировка связанных функций в одном модуле/пакете
- Каждый компонент имеет четкую и единую ответственность (следуя принципу SRP)
- Логическое разделение функциональности по соответствующим слоям
- Структурирование кода по функциональным областям, а не по техническим аспектам

Преимущества высокой связности:
- Код легче понимать, так как он логически организован
- Улучшение переиспользуемости компонентов
- Снижение сложности поддержки и модификации
- Локализация изменений при модификации функциональности

Комбинация слабого зацепления и высокой связности создает архитектуру, где компоненты:
1. Могут легко изменяться независимо друг от друга
2. Внутренне логически организованы и направлены на решение конкретных задач
3. Хорошо тестируются по отдельности
4. Образуют гибкую систему в целом

## Принцип DRY (Don't Repeat Yourself)

1. **Общая логика работы с сообщениями**
    - Применение: выделение общих функций обработки сообщений в отдельные методы
    - Цель: избежание дублирования кода обработки сообщений
    - Пример: общие методы форматирования и обработки сообщений в `MessageService`

2. **Утилиты для работы с BadgerDB**
    - Применение: выделение общих операций с BadgerDB в отдельные функции
    - Цель: централизация логики работы с базой данных
    - Пример: утилиты для чтения/записи в `repo/badger`

3. **Обработка ошибок**
    - Применение: стандартизация создания и обработки ошибок
    - Цель: единый подход к обработке ошибок
    - Пример: централизованные функции создания и логирования ошибок в пакете `errors`

(DRY нужно применять без фанатизма, иногда лучше выполнить copy/paste)

## Принцип KISS (Keep It Simple, Stupid)

1. **Простые и понятные интерфейсы**
    - Применение: минимальные интерфейсы с четкой ответственностью
    - Цель: упрощение интеграции и тестирования компонентов
    - Пример: четкое разделение интерфейсов `MessageService` и `ForwardService`

2. **Простая организация зависимостей**
    - Применение: явная передача зависимостей через конструкторы
    - Цель: понятная и отслеживаемая структура зависимостей
    - Пример: самописный DI без использования сложных фреймворков

3. **Модульная структура**
    - Применение: разделение монолита на небольшие модули с единой ответственностью
    - Цель: упрощение понимания и сопровождения кода
    - Пример: четкое разделение на слои controller, service, repo

4. **Низкая цикломатическая сложность**
    - Применение: стремление к простым функциям с минимальным количеством условных ветвлений
    - Цель: повышение читаемости и тестируемости кода
    - Пример: функции с цикломатической сложностью не более 10-15

5. **Принцип раннего возврата (early return)**
    - Применение: обработка ошибок и граничных случаев в начале функции
    - Цель: уменьшение уровней вложенности и повышение читаемости кода
    - Пример:
    ```go
    // Хороший стиль с ранним возвратом
    func ProcessMessage(msg *Message) error {
        if msg == nil {
            return errors.New("message is nil")
        }

        if err := validateMessage(msg); err != nil {
            return fmt.Errorf("invalid message: %w", err)
        }

        // Основная логика обработки сообщения
        return nil
    }

    // Плохой стиль с глубокой вложенностью
    func ProcessMessagePoor(msg *Message) error {
        if msg != nil {
            if validateMessage(msg) == nil {
                // Основная логика обработки сообщения
                return nil
            } else {
                return errors.New("invalid message")
            }
        } else {
            return errors.New("message is nil")
        }
    }
    ```

## Принципы SOLID

1. **Принцип единственной ответственности (SRP)**
    - Применение: каждый класс имеет только одну ответственность
    - Цель: упрощение сопровождения и тестирования
    - Пример: разделение логики фильтрации (`FilterService`) и пересылки (`ForwardService`)

2. **Принцип открытости/закрытости (OCP)**
    - Применение: расширение функциональности через добавление новых компонентов, а не изменение существующих
    - Цель: минимизация изменений существующего кода
    - Пример: добавление новых стратегий фильтрации без изменения существующих

3. **Принцип подстановки Барбары Лисков (LSP)**
    - Применение: корректное использование интерфейсов и их реализаций
    - Цель: обеспечение взаимозаменяемости объектов одного типа
    - Пример: все реализации `repo/telegram` должны корректно работать в контексте `service/message`

4. **Принцип разделения интерфейса (ISP)**
    - Применение: минимальные и специализированные интерфейсы
    - Цель: клиенты не должны зависеть от методов, которые они не используют
    - Пример: разделение интерфейса работы с сообщениями на более специализированные интерфейсы

5. **Принцип инверсии зависимостей (DIP)**
    - Применение: зависимость от абстракций, а не от конкретных реализаций
    - Цель: уменьшение связанности между компонентами
    - Пример: сервисы зависят от интерфейсов репозиториев, а не от их конкретных реализаций

## Нотация Start и Run

В проекте будет применяться следующая нотация для инициализации и запуска компонентов:

1. **Метод `New*` или конструктор**
    - Создает экземпляр компонента
    - Инициализирует зависимости и внутреннее состояние
    - Не запускает никаких фоновых задач или горутин
    - Пример: `NewMessageService(repo Repo) *MessageService`

2. **Метод `Start`**
    - Подготавливает компонент к работе
    - Устанавливает соединения, инициализирует ресурсы
    - Может быть блокирующим или не блокирующим, в зависимости от контекста
    - В случае ошибки возвращает ее и останавливает запуск приложения
    - Пример: `Start(ctx context.Context) error`

3. **Метод `Run`**
    - Запускает основной цикл работы компонента (обычно блокирующий)
    - Выполняет основную функциональность компонента
    - Работает до получения сигнала завершения через контекст
    - Пример: `Run(ctx context.Context) error`

4. **Метод `Close`**
    - Корректно останавливает компонент, освобождает ресурсы
    - Вызывается при graceful shutdown
    - Пример: `Close() error`

Эта нотация обеспечивает единообразный подход к управлению жизненным циклом всех компонентов и упрощает организацию корректного запуска и остановки системы.

### Сервисы и контроллеры не имеют реализации нотации Start?

Нотация Start должна применяться для компонентов, которые требуют инициализации ресурсов или запуска фоновых процессов.

- **репозитории** (Telegram, Storage) реализуют Start для управления соединениями
- **транспортные слои** (Web, Bot, CLI) реализуют Start для управления серверами и обработчиками

Однако, **сервисы и контроллеры** обычно не имеют своего состояния, требующего инициализации или освобождения ресурсов, поэтому они не должны реализовывать метод Start. Но в особых случаях это допустимо.

Если Start блокирующий, то следует заменить его название на Run.

## Подход к внедрению зависимостей (DI)

Для организации DI будет использован самописный подход на основе использования стандартных механизмов языка Go (context, defer, функции-конструкторы, обработка ошибок), как описано в [статье Vivid Money](https://github.com/vivid-money/article-golang-di):

```go
// Пример организации DI и жизненного цикла в main.go
func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    errSet := &errors.ErrSet{}

    // Обработка сигналов остановки
    go func() {
        util.AwaitSignal(ctx)
        cancel()
    }()

    // Запуск приложения с обработкой ошибок
    if err := runApp(ctx, errSet); err != nil {
        log.Fatalf("Application error: %v", err)
    }

    // Вывод накопленных ошибок при завершении
    if err := errSet.Error(); err != nil {
        log.Printf("Shutdown errors: %v", err)
    }
}

func runApp(ctx context.Context, errSet *errors.ErrSet) error {
    // Инициализация BadgerDB
    storageRepo := badger.New()
    if err := storageRepo.Connect(ctx); err != nil {
        return fmt.Errorf("failed to connect to BadgerDB: %w", err)
    }
    defer util.Shutdown("storageRepo", errSet, storageRepo.Close)

    // Инициализация TDLib
    telegramRepo, err := telegramRepo.New()
    if err != nil {
        return fmt.Errorf("failed to create Telegram repo: %w", err)
    }
    defer util.Shutdown("telegramRepo", errSet, telegramRepo.Close)

    // Инициализация сервисов
    messageService := messageService.New(telegramRepo, storageRepo)
    forwardService := forwardService.New(messageService)

    // Запуск HTTP-сервера
    httpServer := httpTransport.NewHTTPServer(messageService)
    if ctx, err = util.Serve(ctx, "httpServer", errSet, httpServer.Serve); err != nil {
        return fmt.Errorf("failed to serve HTTP: %w", err)
    }
    defer util.Shutdown("httpServer", errSet, httpServer.Close)

    // Ожидание завершения контекста
    <-ctx.Done()
    return ctx.Err()
}
```

## Взаимодействие между слоями

1. **Transport → Controller → Service → Repo**:
    - Транспортные адаптеры вызывают методы соответствующих контроллеров
    - Контроллеры оркестрируют работу сервисов, без собственной бизнес-логики (optional)
    - Сервисы содержат всю бизнес-логику и взаимодействуют с репозиториями
    - Репозитории инкапсулируют доступ к данным

2. **Преобразование данных в Entity**:
    - Entity используются для передачи данных между всеми слоями
    - Entity могут содержать методы для преобразования форматов (сериализация/десериализация)

3. **Обработка ошибок**:
    - Каждый слой должен обрабатывать соответствующие ему ошибки
    - Репозитории возвращают специфичные для хранилища ошибки
    - Сервисы оборачивают ошибки репозиториев в доменные ошибки
    - Контроллеры преобразуют доменные ошибки в понятный формат для клиента
    - Транспортный слой преобразует ошибки в соответствующие форматы протокола

## Модификация подхода к передаче данных

В связи с отказом от отдельного слоя DTO, функциональность передачи данных перешла к Entity:

1. **Entity как средство передачи данных**:
   - Entity используются для передачи данных между всеми слоями системы
   - Entity могут содержать дополнительные методы для преобразования форматов
   - Entity содержат методы сериализации/десериализации для разных форматов (JSON, протоколы)
2. **Методы преобразования форматов в Entity**:
   - Методы для сериализации (`MarshalJSON`, `ToProto`)
   - Методы для десериализации (`UnmarshalJSON`, `FromProto`)
   - Методы для представления в API (`ToResponse`)
   - Методы для валидации (`Validate`)
3. **Пример взаимодействия слоев через Entity**:
   ```go
   // В контроллере
   func (c *MessageController) GetMessage(ctx context.Context, messageId int64) (*entity.Message, error) {
       // Получаем сообщение через сервис
       message, err := c.messageService.GetMessage(ctx, messageId)
       if err != nil {
           return nil, err
       }

       return message, nil
   }

   // В HTTP-обработчике
   func (h *HTTPHandler) HandleGetMessage(w http.ResponseWriter, r *http.Request) {
       // Получаем Id из запроса
       id := getIdFromRequest(r)

       // Получаем сообщение через контроллер
       message, err := h.messageController.GetMessage(r.Context(), id)
       if err != nil {
           handleError(w, err)
           return
       }

       // Используем метод Entity для подготовки ответа
       response := message.ToResponse()

       // Отправляем ответ
       sendJSON(w, response)
   }
   ```

## Создание и обработка ошибок

1. **Типы ошибок**:
   - Ошибки домена (`entity/errors.go`)
   - Ошибки сервисов (`service/errors.go`)
   - Ошибки репозиториев (`repo/errors.go`)
   - Общие ошибки (`errors/common.go`) - deprecated
2. **Обертывание ошибок**:
   - Использование `fmt.Errorf("context: %w", err)` для добавления контекста
   - Использование `errors.Is` и `errors.As` для проверки типов ошибок
   - Сохранение стек-трейса с помощью библиотеки `github.com/pkg/errors`
3. **Обработка ошибок в разных слоях**:
   - Репозитории: возвращают специфичные ошибки хранилища
   - Сервисы: преобразуют ошибки репозиториев в доменные ошибки
   - Контроллеры: определяют, как обрабатывать ошибки (повтор, отклонение и т.д.)
   - Транспортный слой: преобразует ошибки в соответствующие HTTP-коды, сообщения и т.д.
4. **Пример обработки ошибок**:
   ```go
   // В репозитории
   func (r *MessageRepo) GetMessage(id int64) (*entity.Message, error) {
       message, err := r.db.Get(id)
       if err != nil {
           if errors.Is(err, badger.ErrKeyNotFound) {
               return nil, repo.ErrMessageNotFound
           }
           return nil, fmt.Errorf("getting message from database: %w", err)
       }
       return message, nil
   }

   // В сервисе
   func (s *MessageService) GetMessage(ctx context.Context, id int64) (*entity.Message, error) {
       message, err := s.repo.GetMessage(id)
       if err != nil {
           if errors.Is(err, repo.ErrMessageNotFound) {
               return nil, service.ErrMessageNotFound
           }
           return nil, fmt.Errorf("getting message from repo: %w", err)
       }
       return message, nil
   }

   // В HTTP-обработчике
   func handleError(w http.ResponseWriter, err error) {
       switch {
       case errors.Is(err, service.ErrMessageNotFound):
           http.Error(w, "Message not found", http.StatusNotFound)
       case errors.Is(err, service.ErrValidation):
           http.Error(w, err.Error(), http.StatusBadRequest)
       default:
           log.Printf("Unexpected error: %v", err)
           http.Error(w, "Internal server error", http.StatusInternalServerError)
       }
   }
   ```
5. **Форматирование ошибок**:
    - На английском языке
    - С большой буквы
    - Без точки в конце

## Соглашения по интеграции с go-tdlib и созданию структур данных

1. **Минимизация дублирования** - максимально использовать структуры go-tdlib, избегая создания дублирующих структур.
2. **Композиция вместо наследования** - использовать композицию структур go-tdlib в наших сущностях там, где это возможно.
3. **Сущности как простые структуры данных** - сущности (entity) должны содержать только структуры данных, конструкторы и простые геттеры/сеттеры, без сложной бизнес-логики.
4. **Бизнес-логика в сервисном слое** - вся бизнес-логика должна быть в сервисном слое, а не в сущностях.
5. **Интерфейсы для репозиториев** - определять чёткие интерфейсы для репозиториев, следуя идиоме "принимаем интерфейсы, возвращаем конкретные типы".
6. **DTO только при необходимости преобразования** - использовать DTO только когда формат данных должен отличаться от Entity (для API, конфигурации, специальных представлений).

## Использование интерфейсов

Для обеспечения слабой связанности компонентов и возможности тестирования следует использовать интерфейсы:

```go
// Пример интерфейса контроллера
type MessageController interface {
    GetMessage(chatId, messageId int64) (*model.Message, error)
    SendMessage(message *model.Message) (*model.Message, error)
    EditMessage(chatId, messageId int64, text string) (*model.Message, error)
    DeleteMessage(chatId, messageId int64) error
}

// Пример интерфейса сервиса
type MessageService interface {
    GetMessage(chatId, messageId int64) (*entity.Message, error)
    SendMessage(message *entity.Message) (*entity.Message, error)
    EditMessage(chatId, messageId int64, text string) (*entity.Message, error)
    DeleteMessage(chatId, messageId int64) error
}

// Пример интерфейса репозитория
type TelegramRepo interface {
    SendMessage(chatId int64, text string) (*entity.Message, error)
    GetMessage(chatId, messageId int64) (*entity.Message, error)
    DeleteMessage(chatId, messageId int64) error
}
```

### Локальное объявление интерфейсов

Применяется подход с локальным объявлением интерфейсов в тех же файлах, где они используются. Это соответствует принципу "Interface Segregation" (ISP) из SOLID и обеспечивает лучшую обособленность модулей:

```go
// Локальное объявление интерфейса в начале файла (после секции импортов)
type SomeObj interface {
  SomeMethod()
}

type Service struct {
  someObj SomeObj
}

func NewService(someObj SomeObj)* Service {
  return &Service{someObj: someObj}
}

func (s Service) ServiceMethod() {
  s.someObj.SomeMethod()
}
```

Локальные интерфейсы для собственных структур (например, для сервисов) не объявляются, т.к. они не используются по этой схеме.

## Идиома передачи интерфейсов и возврата структур

В проекте будет применяться следующая идиома Go:

**"Принимай интерфейсы, возвращай структуры" (Accept interfaces, return structs)**

Эта идиома предписывает:
- Функции-конструкторы должны принимать параметры с типом интерфейса, а не конкретной структуры
- Функции-конструкторы должны возвращать конкретные типы, а не интерфейсы

```go
// Правильно - принимаем интерфейс, возвращаем структуру
func NewMessageService(repo TelegramRepo) *MessageService {
    return &MessageService{repo: repo}
}

// Неправильно - возвращаем интерфейс вместо структуры
func NewMessageService(repo TelegramRepo) MessageServiceInterface {
    return &MessageService{repo: repo}
}
```

Преимущества этого подхода:
1. **Гибкость** - функции работают с любыми объектами, реализующими необходимый интерфейс
2. **Тестируемость** - можно легко создавать моки для тестирования
3. **Конкретность** - клиенты всегда знают конкретный тип возвращаемого объекта
4. **Отсутствие лишних абстракций** - интерфейсы определяются потребителями, а не производителями

Применение этой идиомы повышает гибкость кода, упрощает тестирование и соответствует принципам Go по работе с интерфейсами.

### Ограничение на применение идиомы только в функциях-констукторах

В Go два интерфейса с одинаковыми методами считаются совместимыми (compatible), но типы функций с разными именованными типами в сигнатуре - нет, даже если эти типы имеют одинаковые интерфейсы.

Например:
```go
type driver1 interface { Method() }
type driver2 interface { Method() }

// Это работает:
var d1 driver1 = someImplementation{}
var d2 driver2 = d1

// А это нет:
type fn1 func(driver1)
type fn2 func(driver2)
var f1 fn1 = func(d driver1) {}
var f2 fn2 = f1 // ошибка компиляции
```

Из-за этого ограничения нельзя использовать передачу интерфейсов в аргументах методов других интерфейсов. Идиома применима только в функциях-констукторах.

## Частичное применение интерфейса

### Принцип

Каждый модуль определяет в своём пакете локальный интерфейс, содержащий только те методы зависимости, которые он реально использует. Это позволяет явно обозначить требования модуля и упростить тестирование.

### Основные преимущества

- **Interface Segregation Principle**: соблюдение принципа разделения интерфейсов
- **Слабая связанность**: модуль не зависит от неиспользуемых методов
- **Читаемость**: сразу видно, какие именно методы использует модуль
- **Тестируемость**: нужно мокать только используемые методы

### Пример

```go
// repo/telegram/repo.go

type Repo struct {}

func (r *Repo) CreateClient(runAuthorizationStateHandler) { ... }
func (r *Repo) GetClientDone() <-chan any { ... }
// Другие методы ...
```

```go
// service/auth/service.go

//go:generate mockery --name=telegramRepo --exported
type telegramRepo interface {
	// Только используемые методы
  CreateClient(runAuthorizationStateHandler)
	GetClientDone() <-chan any
}

func New(telegramRepo telegramRepo) *Service
```

### Дополнительный приём: адаптер сторонней зависимости

**Проблема**
При работе со сторонними библиотеками (например, `tdlibClient`) модули получают прямую зависимость от внешнего API, что усложняет тестирование и создаёт жёсткую связанность.

**Решение: clientAdapter**
```go
// repo/telegram/client_adapter.go

type clientAdapter interface {
  // Обёртки методов tdlibClient
	GetListener() *client.Listener
  // Другие объявления ...
}

func (r *Repo) GetListener() *client.Listener {
	return r.getClient().GetListener()
}

// Другие реализации ...
```

```go
// repo/telegram/repo.go

type Repo struct {
  clientAdapter // внедрение интерфейса адаптера
}

// Собственные методы репозитория
func (r *Repo) CreateClient(runAuthorizationStateHandler) { ... }
func (r *Repo) GetClientDone() <-chan any { ... }
```

```go
// service/engine/service.go

//go:generate mockery --name=telegramRepo --exported
type telegramRepo interface {
	CreateClient(runAuthorizationStateHandler)
	GetClientDone() <-chan any
  GetListener() *client.Listener // tdlibClient метод через clientAdapter
}
```

**Зачем нужен адаптер**

На первый взгляд `clientAdapter` кажется избыточным — он просто пробрасывает методы `tdlibClient` без изменения сигнатур. Однако он предоставляет возможность частичного применения интерфейса. Модули получают в конструкторе не полный `clientAdapter` или `tdlibClient`, а минимальный локальный интерфейс `telegramRepo` только с используемыми методами. Это делает код более читаемым, тестируемым и поддерживаемым.

## Соглашение об именовании колбеков

### Контекст и мотивация

В Go идеальный интерфейс содержит один метод, именуемый глаголом. Название такого интерфейса образуется от названия метода путем преобразования глагола в существительное через суффикс `-er`.

Для **"частично применяемых интерфейсов"** в сочетании с идиомой **"Accept interfaces, return structs"** возникает ограничение: нельзя использовать интерфейсы в качестве параметров методов других интерфейсов из-за несовместимости типов функций с именованными типами в Go.

**Решение**: на замену идеальному интерфейсу, использование колбеков (функций первого класса) в качестве параметров методов частично применяемых интерфейсов.

Но, в отличие от идеальных интерфейсов, функции и методы принято именовать с глагола + опциональное существительное.

### Принципы именования колбеков

**1. Именование колбеков**

```go
// Правильно - глагол в нижнем регистре + опциональное существительное
type notify = func(message string) error
type checkBalance = func(data interface{}) error

// Неправильно - существительные или другие формы
type Notifier func(message string) error // существительное
type OnNotify func(message string) error // prefix "On"
```

**2. Функции-конструкторы для замыканий**

Для создания замыканий колбеков используются функции-конструкторы с префиксом `NewFunc`:

```go
// Правильно - NewFunc + глагол с заглавной буквы
func NewFuncNotify(logger Logger) notify {
    return func(message string) error {
        return logger.Log(message)
    }
}

func NewFuncAuthenticate(repo UserRepo) authenticate {
    return func(credentials Credentials) (*User, error) {
        return repo.FindByCredentials(credentials)
    }
}

// Неправильно - обычное именование функций
func NewNotify(logger Logger) notify        // вводит в заблуждение
func CreateNotifier(logger Logger) notify   // не следует соглашению
func MakeNotifyFunc(logger Logger) notify   // избыточность
```

**3. Обоснование именования NewFunc**

**Проблема**: Если функции именуются глаголами (например, `notify()`), то `NewNotify()` создает путаницу - непонятно, создается ли функция или вызывается действие.

**Решение**: Префикс `NewFunc` явно указывает, что создается функция-замыкание:
- `NewFuncNotify()` - создает функцию уведомления
- `notify()` - выполняет уведомление

### Пример

```go
// Определение алиаса для колбека
type process = func(data []byte) error

// Функция-конструктор для создания замыкания
func NewFuncProcess(validator Validator, transformer Transformer) process {
    return func(data []byte) error {
        if err := validator.Validate(data); err != nil {
            return fmt.Errorf("validation failed: %w", err)
        }

        transformed, err := transformer.Transform(data)
        if err != nil {
            return fmt.Errorf("transformation failed: %w", err)
        }

        // Дополнительная логика обработки
        return nil
    }
}

// Использование в частично применяемом интерфейсе
type dataProcessor interface {
    ProcessData(data []byte, process process) error
}

// Идиома "Accept interfaces, return structs"
func NewService(dataProcessor dataProcessor) *Service
```

## Соглашение о контроле области видимости переменных

Для предотвращения проблемы скрытого переиспользования переменной `err` и других подобных переменных будет применяться ограничение области видимости с помощью фигурных скобок. Это позволит избежать потенциальных уязвимостей безопасности и логических ошибок.

**Пример правильного использования:**

```go
var v1 V1
{
    v1Tmp, err := NewV1()
    if err != nil {
        log.Error(err)
        return err
    }
    v1 = v1Tmp
}

var v2 V2
{
    v2Tmp, err := NewV2()
    if err != nil {
        log.Error(err)
        return err
    }
    v2 = v2Tmp
}
```

**Или альтернативный вариант:**

```go
{
    v1, err := NewV1()
    if err != nil {
        log.Error(err)
        return err
    }
    // использование v1
}

{
    v2, err := NewV2()
    if err != nil {
        log.Error(err)
        return err
    }
    // использование v2
}
```

## Соглашения по тестированию

- [testing/synctest experiment for time and concurrency testing](https://danp.net/posts/synctest-experiment/)
- Применяется `assert.AnError` вместо `errors.New("some error")`
- Применяется `t.Parallel()` и флаг для выявления гонки данных
- Применяется AAA (Arange Act Asset), т.е. assert-ы для проверки условий, а request-для проверки сетапа
- Юнит-тесты размещаются в том же пакете, что и тестируемый код, с суффиксом `_test.go`
- Интеграционные тесты размещаются в директории `/test`
- Для каждой функциональной единицы должны быть написаны тесты, покрывающие основные сценарии использования
- Покрытие юнит-тестами выполняется с конца тестируемого файла, т.е от частного к общему (при условии, что методы в файле расположены в порядке: публичные, непубличные, утилиты)

### Виды юнит-тестов

В проекте будут применяться два основных вида юнит-тестов:

1. **Тесты для покрытия кодовой базы**
    - Цель: обеспечение технического качества кода и предотвращение регрессий
    - Фокус: тестирование отдельных функций и методов, проверка корректности обработки граничных случаев
    - Особенности:
        - Обычно более детализированы и многочисленны
        - Проверяют корректность реализации, а не бизнес-ценность
        - Полезны при рефакторинге для обеспечения сохранения функциональности
    - Пример: тестирование утилитарных функций, методов доступа к данным, преобразований данных

2. **Тесты для покрытия бизнес-логики**
    - Цель: проверка соответствия кода бизнес-требованиям
    - Фокус: тестирование бизнес-сценариев и потоков, проверка правильности бизнес-решений
    - Особенности:
        - Написаны с точки зрения бизнес-требований
        - Охватывают ключевые сценарии использования системы
        - Служат как документация бизнес-процессов
    - Пример: тестирование правил фильтрации сообщений, логики пересылки, генерации отчетов

Оба вида тестов необходимы для обеспечения качества системы, но имеют разные цели и подходы. Первый вид обеспечивает надежность технической реализации, второй – соответствие бизнес-потребностям.

### Реализация

Преимущественно в проекте применяются табличные (table-driven) тесты:
- Каждый тест-кейс определяется как отдельная строка в таблице тестовых данных
- Тесты слабосвязаны - каждый тест является атомарным и не зависит от результатов других тестов
- Одинаковая инициализация и проверка выполнения для всех тестовых случаев
- Улучшенная читаемость и расширяемость - добавление нового тест-кейса требует только добавления строки в таблицу

В частности, предпочтительно используются call-тесты:
- В каждом табличном тесте определены функции для подготовки входных данных и проверки выходных
- Эти функции независимы и атомарны для каждого тест-кейса
- Позволяют сфокусироваться на тестируемом поведении, абстрагируясь от деталей подготовки данных

Пример структуры табличного call-теста:
```go
func TestFormatMessage(t *testing.T) {
    tests := []struct {
        name           string
        // Функции для подготовки входных данных
        setupInput     func() string
        setupMocks     func() *mocks.MockFormatter
        // Ожидаемый результат и функция проверки
        expectedOutput string
        verifyFunc     func(t *testing.T, result string, err error, formatter *mocks.MockFormatter)
    }{
        {
            name: "Успешное форматирование",
            setupInput: func() string {
                return "Исходный текст"
            },
            setupMocks: func() *mocks.MockFormatter {
                formatter := mocks.NewMockFormatter(t)
                formatter.EXPECT().Format(gomock.Any()).Return("Отформатированный текст", nil)
                return formatter
            },
            expectedOutput: "Отформатированный текст",
            verifyFunc: func(t *testing.T, result string, err error, formatter *mocks.MockFormatter) {
                assert.NoError(t, err)
                assert.Equal(t, "Отформатированный текст", result)
            },
        },
        {
            name: "Обработка пустой строки",
            setupInput: func() string {
                return ""
            },
            setupMocks: func() *mocks.MockFormatter {
                formatter := mocks.NewMockFormatter(t)
                formatter.EXPECT().Format(gomock.Any()).Return("", errors.New("empty input"))
                return formatter
            },
            expectedOutput: "",
            verifyFunc: func(t *testing.T, result string, err error, formatter *mocks.MockFormatter) {
                assert.Error(t, err)
                assert.Equal(t, "", result)
                assert.Contains(t, err.Error(), "empty input")
            },
        },
        // другие тест-кейсы
    }

    for _, test := range tests {
        t.Run(test.name, func(t *testing.T) {
            t.Parallel()

            // Атомарная инициализация для каждого тест-кейса
            input := test.setupInput()
            formatter := test.setupMocks()

            // Выполнение тестируемой функции
            result, err := FormatMessage(input, formatter)

            // Проверка результата через функцию проверки
            test.verifyFunc(t, result, err, formatter)
        })
    }
}
```

Преимущества call-тестов:
1. **Гибкость** - можно легко менять стратегию подготовки данных и проверки результатов
2. **Изоляция** - каждый тест-кейс полностью изолирован и имеет собственный контекст
3. **Читаемость** - лучшая организация кода с фокусом на тестируемом поведении
4. **Расширяемость** - легко добавлять новые тест-кейсы без дублирования кода

## Соглашение о лишних проверках

Лишние проверки зашумливают код, без особой необходимости лучше их не применять.

```go
func (s *Service) GetMessage() {
	tdlibClient := s.telegramRepo.GetClient()
    // тут будет лишней проверка, что tdlibClient != nil
    // пока не инициализирован tdlibClient,
    // мы никакие методы не вызываем

    message, err := tdlibClient.GetMessage()
    //...
```

```go
func (s *Service) sendMessage(message *client.Message) {
    // тут будет лишней проверка на входные параметры,
    // т.к. мы доверяем собственной реализации
    // ...
}
```

## Глобальный config

Конфигурация приложения реализуется через глобальные переменные без необходимости мокирования в тестах, потому как в конфиге нет функций, только данные.

**Принципы:**
- Глобальные переменные для хранения конфигурации
- Все варианты конфигурации для различных тестов прописаны в едином тестовом конфиге
- Параллельное выполнение тестов не конфликтует благодаря централизованному хранению всех настроек в одном файле

**Преимущества:**
- Упрощение тестирования - не требуется мокирование конфига
- Безопасность параллельных тестов - все настройки в одном месте исключают конфликты
- Централизованное управление всеми настройками

## Подходы к асинхронному программированию

В Go существует два основных подхода к работе с асинхронными операциями и временными задержками, которые можно сравнить с парадигмами из JavaScript:

### Функциональный подход: `context.AfterFunc()` & `time.AfterFunc()` ≈ Promise

**Характеристики:**
- Декларативный стиль программирования
- Использование колбеков (callback functions)
- Цепочки действий (chaining)
- Автоматическое управление ресурсами

**Пример в Go:**
```go
func scheduleTask(ctx context.Context) {
    var timer *time.Timer

    // Автоматическая отмена при отмене контекста
    stop := context.AfterFunc(ctx, func() {
        if timer != nil {
            timer.Stop()
        }
    })

    // Планирование выполнения через колбек
    timer = time.AfterFunc(1*time.Second, func() {
        stop()
        processTask()
        scheduleTask(ctx) // Цепочка следующего действия
    })
}
```

**Аналогия с JavaScript Promise:**
```javascript
function scheduleTask() {
    return new Promise((resolve) => {
        setTimeout(resolve, 1000)
    })
    .then(() => {
        processTask()
        return scheduleTask() // Цепочка
    })
    .catch(() => {
        // Обработка отмены
    })
}
```

### Императивный подход: `select` ≈ `async/await`

**Характеристики:**
- Императивный стиль программирования
- Линейная последовательность операций
- Явное управление потоком выполнения
- Простая читаемость для новичков

**Пример в Go:**
```go
func runLoop(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return // Выход при отмене
        case <-ticker.C:
            processTask() // Ожидание и выполнение
        }
    }
}
```

**Аналогия с JavaScript async/await:**
```javascript
async function runLoop(signal) {
    while (!signal.aborted) {
        try {
            await sleep(1000) // Ожидание как в select
            processTask()
        } catch (error) {
            return // Выход при отмене
        }
    }
}
```

### Сравнение подходов

| Критерий | Функциональный (`AfterFunc`) | Императивный (`select`) |
|----------|------------------------------|-------------------------|
| **Читаемость** | Сложнее для новичков | Проще и понятнее |
| **Производительность** | Меньше горутин | Больше ресурсов |
| **Управление ресурсами** | Автоматическое | Ручное |
| **Отмена операций** | Встроенная в колбек | Явная проверка |
| **Цепочки действий** | Естественные | Требуют дополнительной логики |
| **Тестируемость** | Сложнее мокировать | Проще тестировать |

### Рекомендации по применению

**Используйте функциональный подход (`context.AfterFunc()`) когда:**
- ✅ Одноразовые операции с таймаутом
- ✅ Сложная логика отмены операций
- ✅ Цепочки асинхронных действий
- ✅ Нужна высокая производительность (меньше горутин)

**Пример применения:**
```go
// Rate limiter с разовыми задержками
func (s *Service) WaitForForward(ctx context.Context, chatId int64) {
    if delay := s.calculateDelay(chatId); delay > 0 {
        done := make(chan struct{})

        stop := context.AfterFunc(ctx, func() {
            close(done)
        })

        timer := time.AfterFunc(delay, func() {
            close(done)
        })

        <-done
        timer.Stop()
        stop()
    }
}
```

**Используйте императивный подход (`select`) когда:**
- ✅ Циклические операции
- ✅ Множественные каналы для обработки
- ✅ Простая и понятная логика
- ✅ Команда состоит из новичков в Go

**Пример применения:**
```go
// Обработчик очереди с циклическим выполнением
func (s *Repo) run(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            s.processQueue()
        }
    }
}
```

### Принятый подход в проекте

**В данном проекте мы преимущественно используем императивный подход** по следующим причинам:

1. **Простота и читаемость** - код легче понимать и поддерживать
2. **Стандартность** - соответствует идиомам Go и CSP модели
3. **Отладка** - проще отслеживать выполнение и состояние
4. **Тестирование** - лучше работает с `testing/synctest`

## Конфигурации для разработки и тестирования

### Архитектура конфигурации

- **Единый глобальный конфиг** (не передается как аргумент в объекты):
  - **Преимущество**: обеспечивает принцип "единого источника правды", предотвращая фрагментацию конфигурации, что критично для поддержки большого объема тестов
  - **Недостаток**: исключает возможность параллельного тестирования с различными вариантами конфигурации

### Иерархия переопределения настроек

Значения `defaultConfig()` → переопределяются в `config.yml` → переопределяются в `.env`

### Принципы конфигурирования

- `defaultConfig()` содержит валидное состояние для разработки, позволяя любому разработчику клонировать проект и немедленно запустить его или выполнить тесты

- `config.yml` распространяется вместе с проектом и содержит все настройки в закомментированном виде (за исключением `config.Engine`), поскольку они переопределяют значения по умолчанию и необходимы для конфигурирования системы в проде

- `config.Engine` не имеет настроек по умолчанию и конфигурируется через `config.yml`, поскольку эти параметры предназначены для запуска в режиме разработки и тестирования

### Ограничения тестирования

Для одного аккаунта Telegram поддерживается только один поток сообщений, что исключает возможность параллельного выполнения e2e-тестов.

Нельзя модифицировать конфиг для тестирования. Это приведёт к ошибкам при параллельном выполнении тестов. Нужно соблюдать режим read-only, перезаписывать только через опции, как например `telegramRepo.WithOptions()` или `cliTransport.WithPhoneNumber()`.

## Соглашение о нумерации чатов в тестах

### **Схема префиксов:**
- `100xx` - common (переиспользуемые между модулями данные)
- `101xx` - service.transform
- `102xx` - service.engine
- `103xx` - service.forwarder
- ...

### **Структура номера:**
- **3 цифры** = условный номер модуля
- **2 цифра** = индекс внутри модуля (xx)

### **Ограничения:**
- Максимум **100 модулей** (100-199)
- Максимум **100 значений** на модуль (00-99)

### **Правила:**
1. **Комментарий в начале** тестового файла: `// data for service.transform - 101xx`
2. **Комментарий в config.yml**: `# data for service.transform - 101xx`
3. **Изоляция данных** - каждый модуль использует свой диапазон (бывают исключения)

### **Пример:**
```yaml
# config.yml
10100: # sign only test
10101: # link only test
10109: # destination chat
```

```go
// service_test.go
ChatId: 10100, dstChatId: 10109
```

## Фиксация тех-долга

Когда ковыряешь код, и обнаруживаешь тех-долг, то есть несколько способов его обработать в зависимости от приоритета:

- Пояснительная пометка - просто коммент, "для потомков".

- Абстрактное желание что-то сделать в будущем - коммент с префиксом "TODO:" по месту (не надо объяснять контекст), или в начало `main.go`.

- Надо бы сделать - заводи отдельную задачу.

- Мешает жить - делай в рамках текущей задачи отдельным коммитом.

Это подход снимает когнитивную нагрузку, чтобы фокусироваться на основной задаче.
