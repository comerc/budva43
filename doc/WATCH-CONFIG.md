# Замыкание конфигурации engine в задачах очереди

## Проблема

При добавлении задачи в очередь нужно зафиксировать текущую версию конфигурации engine, чтобы задача выполнилась именно с той конфигурацией, которая была актуальна в момент создания этой задачи.

## Решение

Используется **замыкание** - конфигурация копируется в локальную переменную и замыкается в функции задачи.

```go
func (h *Handler) Run(update *client.UpdateDeleteMessages) {
    // Копируем конфиг в локальную переменную
    engineConfig := config.Engine 
    
    var fn func()
    fn = func() {
        // engineConfig замкнут в этой функции
        h.deleteMessages(chatId, messageIds, data, engineConfig)
        
        // Можно повторно добавить ту же функцию
        if needRetry {
            h.queueRepo.Add(fn) 
        }
    }
    
    h.queueRepo.Add(fn)
}
```

### Преимущества

- **Простота** - никаких специальных методов, обычное замыкание Go
- **Стабильность** - каждая задача использует конфигурацию на момент её создания
- **Предсказуемость** - перезагрузка конфигурации не влияет на уже добавленные задачи

### Горячая перезагрузка конфигурации

Конфигурацию engine можно перезагружать во время работы программы:

```go
// Перезагрузка из config/engine.yml
err := engine_config.Reload()
```

**Поведение при перезагрузке:**
- **Новые задачи** используют новую конфигурацию
- **Задачи в очереди** продолжают работать со старой замкнутой конфигурацией

Это обеспечивает плавный переход без сломанных задач.

**Статус:** ✅ Реализовано и протестировано 