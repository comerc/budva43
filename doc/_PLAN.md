# Техническое задание на рефакторинг приложения Budva32 > Budva43

## Текущее состояние проекта

Проект [Budva32](https://github.com/comerc/budva32) представляет собой монолитное приложение, написанное на Go, которое взаимодействует с Telegram API через TDLib. Основная функциональность включает:
- Перенаправление и копирование сообщений между чатами/каналами
- Редактирование сообщений перед пересылкой
- Обработку медиа-файлов (изображения, документы, видео и т.д.)
- Фильтрацию сообщений по различным критериям
- Генерацию отчётов
- Хранение данных с использованием BadgerDB
- Базовый веб-интерфейс

В текущей реализации почти вся бизнес-логика находится в одном файле `main.go` (более 2000 строк кода), что затрудняет сопровождение, тестирование и дальнейшую разработку проекта.

## Цель рефакторинга

Целью рефакторинга является разделение монолитного приложения на отдельные функциональные модули с четкими границами ответственности, что позволит:
- Улучшить читаемость и поддерживаемость кода
- Обеспечить возможность независимого тестирования компонентов
- Упростить дальнейшую разработку и расширение функциональности
- Применить принципы чистой архитектуры

## Этапы рефакторинга

### Этап 1: Выделение функциональных модулей

Первый этап предполагает создание одноуровневой иерархии файлов и папок, основанной на принципах чистой архитектуры. Результатом этого этапа должна быть структура проекта, соответствующая следующему шаблону:

#### Структура директорий

```
budva43/
├── main.go               # Точка входа в приложение (инициализация и DI)
├── config/               # Конфигурация приложения
├── entity/               # Бизнес-сущности (и объекты передачи данных)
├── repo/                 # Интерфейсы и реализации доступа к внешним системам
│   ├── storage/          # Реализация репозитория для BadgerDB
│   └── telegram/         # Реализация репозитория для Telegram API
├── service/              # Бизнес-логика приложения (Use Cases)
├── controller/           # Контроллеры по бизнес-сущностям
├── transport/            # Транспортные адаптеры по протоколам
│   ├── web/              # HTTP-API и веб-сервер
│   ├── bot/              # Обработка Telegram Bot API
│   └── term/             # Интерфейс командной строки
├── util/                 # Утилиты и вспомогательные функции
├── doc/                 # Документация
└── test/                 # Интеграционные тесты
```

### Назначение директорий:

1. **main.go**
    - Точка входа в приложение
    - Инициализация зависимостей, настройка DI, запуск горутин и серверов
    - Организация жизненного цикла приложения
    - Реализация механизма "Graceful Shutdown":
        - Корректная обработка сигналов SIGINT, SIGTERM
        - Ожидание завершения работы всех активных обработчиков
        - Последовательное закрытие всех компонентов в обратном порядке их инициализации
        - Установка таймаута для принудительного завершения в случае зависания
        - Логирование процесса завершения работы
        - Кейсы завершения работы:
            - Обработка HTTP-запроса `/shutdown` (административное завершение)
            - Обработка случаев аварийного завершения `/crash` (с логированием причин)
            - Обработка сигнала прерывания CTRL+C (корректное завершение по сигналу)

2. **config/**
    - Структуры и методы для работы с конфигурацией
    - Чтение и валидация конфигурационных файлов
    - Отслеживание изменений конфигурации

3. **entity/**
    - Бизнес-сущности системы
    - Содержит структуры данных, представляющие модель данных
    - Включает методы для сериализации/десериализации и преобразования форматов
    - Содержит методы для передачи данных между слоями (ранее функционал DTO)
    - Для простых структур данных не используются функции-конструкторы
    - Не содержит сложной бизнес-логики
    - Не зависит от внешних слоев и фреймворков
    - Структуры из внешних библиотек (go-tdlib) тут не дублируются, а используются напрямую, но возможны исключения

4. **repo/**
    - Интерфейсы и реализации для доступа к внешним системам
    - Структура пакетов, например: `repo/storage` будет содержать файл `repo.go` для работы с BadgerDB
    - Абстрагирует логику работы с хранилищами данных (BadgerDB)
    - Адаптеры для внешних API (TDLib)
    - Реализует паттерн репозиторий

5. **service/**
    - Содержит всю бизнес-логику приложения
    - Координирует взаимодействие между репозиториями и сущностями
    - Содержит основные сценарии использования (Use Cases)
    - Реализует все алгоритмы, правила и поведение сущностей
    - Не зависит от деталей представления или хранения данных

6. **controller/**
    - Контроллеры по бизнес-сущностям
    - Оркестрируют работу сервисов для выполнения бизнес-задач
    - Вызывают методы сервисов и координируют их работу
    - Независимы от транспортного слоя
    - Возвращают структурированные данные (не привязаны к конкретному протоколу)
    - Примеры:
        - `message/` - контроллер для работы с сообщениями
        - `forward/` - контроллер для пересылки
        - `report/` - контроллер для отчетов

7. **transport/**
    - Транспортные адаптеры по протоколам
    - Содержат код для работы с конкретными протоколами (HTTP, Telegram, Term)
    - Вызывают соответствующие методы контроллеров
    - Преобразуют входные данные из протокола в формат для контроллеров
    - Преобразуют выходные данные контроллеров в формат протокола
    - Примеры:
        - `http/` - HTTP-роутеры и middleware
        - `telegram/` - обработка Telegram Bot API
        - `term/` - интерфейс командной строки

8. **middleware/**
    - Промежуточное ПО для обработки HTTP-запросов
    - Аутентификация, логирование, обработка ошибок

9. **util/**
    - Вспомогательные функции и утилиты
    - Общие инструменты, используемые в разных частях приложения
    - Для более сложных утилит, рассмотреть вынос в отдельные репозитории (вместо добавления локальной папки pkg)


### Этап 2: Выделение и реорганизация структур данных

На этом этапе необходимо:
1. Определить основные бизнес-сущности (Entity) как структуры данных с необходимыми методами
2. Расширить Entity методами для передачи и преобразования данных (ранее функционал DTO)

### Этап 3: Рефакторинг бизнес-логики в сервисы

На этом этапе необходимо:
1. Выделить основные сервисы, реализующие бизнес-логику
2. Определить интерфейсы сервисов и их взаимодействие

#### Полная структура сервисов:
- `UserService` - работа с пользователями
- `ChatService` - работа с чатами
- `ForwardRuleService` - логика пересылки сообщений
- `SourceService` - работа с источниками сообщений
- `ReportService` - генерация отчетов
- `MessageService` - обработка и преобразование сообщений
- `TransformService` - преобразование и замена текста
- `FilterService` - фильтрация сообщений
- `LinkService` - обработка ссылок
- `MediaService` - работа с медиа-файлами
- `StorageService` - абстракция для работы с хранилищем
- `ConfigService` - работа с конфигурацией
- `AuthService` - аутентификация и авторизация
- `NotificationService` - отправка уведомлений
- `CommandService` - обработка команд пользователя
- `AutoAnswerService` - автоматические ответы
- `MonitoringService` - мониторинг состояния приложения

### Этап 4: Выделение репозиториев и контроллеров

На этом этапе необходимо:
1. Определить интерфейсы репозиториев и их реализации
2. Выделить контроллеры для обработки внешних запросов

#### Предлагаемые репозитории:
- `TelegramRepo` - взаимодействие с Telegram API
- `StorageRepo` - работа с BadgerDB
- `ConfigRepo` - доступ к конфигурации

#### Предлагаемые контроллеры:
- `MessageController` - контроллер для работы с сообщениями
- `ForwardController` - контроллер для пересылки сообщений
- `ReportController` - контроллер для генерации отчетов

#### Предлагаемые транспортные адаптеры:
- `HTTPRouter` - обработка HTTP-запросов
- `TelegramHandler` - обработка событий от Telegram
- `TermHandler` - обработка команд из консоли

### Этап 5: Внедрение зависимостей и рефакторинг точки входа

На этом этапе необходимо:
1. Реализовать механизм внедрения зависимостей (DI)
2. Рефакторинг `main.go` для использования выделенных компонентов

## Критерии приемки

1. Монолитный код разделен на логические компоненты согласно предложенной структуре
2. Компоненты имеют четкие границы ответственности
3. Интерфейсы определены для всех ключевых сервисов и репозиториев
4. Функциональность приложения полностью сохранена
5. Добавлены юнит-тесты для ключевых компонентов
6. Код соответствует принципам DRY, KISS и SOLID

## Риски и ограничения

1. Сложность переноса логики, тесно связанной с контекстом выполнения
2. Необходимость сохранения совместимости с существующими данными
3. Возможность появления регрессий в функциональности
4. Необходимость тщательного тестирования каждого компонента

## Дальнейшие шаги после рефакторинга

1. Разработка полноценного набора тестов (unit, integration, e2e)
2. Улучшение документации API и компонентов
3. Рефакторинг бизнес-логики для улучшения производительности и масштабируемости
4. Расширение функциональности на основе новой архитектуры

## Дополнительно

- [Декларация следования принципам ](./DECLARATION.md)
- [Соглашения](./CONVENTIONS.md)
- [Архитектура v2](./ARCHITECTURE-V2.md)
- [Шаблоны проектирования](./DESIGN-PATTERNS.md)
- [Конечный автомат](./FSM.md)
- [Архитектурные приёмы для обеспечения высокой нагрузки](./HIGHLOAD.md)
- [Разграничение бизнес-правил (deprecated)](./_BUSINESS-RULES.md)
- [Сопоставление DAO и DTO (deprecated)](./_DAO&DTO.md)
- [Почему model (deprecated)](./_MODEL.md)
- [Транспортный слой](./TRANSPORT.md)
- [Обсуждения](./DISCUSSION.md)
- [Технический долг](./TECH-DEBT.md)
