# Обсуждения

## Кодогенерация моделей DTO

Для генерации моделей DTO из спецификаций API существуют различные инструменты:

### 1. Инструменты для OpenAPI/Swagger:

- **oapi-codegen**: Генерирует клиентский и серверный код Go из OpenAPI 3.0
  ```bash
  go install github.com/deepmap/oapi-codegen/cmd/oapi-codegen@latest
  oapi-codegen -package api openapi.yaml > api/api.gen.go
  ```

- **go-swagger**: Более комплексный инструмент для работы со Swagger 2.0
  ```bash
  go install github.com/go-swagger/go-swagger/cmd/swagger@latest
  swagger generate model -f openapi.yaml -t api
  ```

### 2. Для GraphQL:

- **gqlgen**: Генерирует код для работы с GraphQL в Go
  - Создание схемы: `gqlgen init`
  - Генерация кода: `gqlgen generate`
  - Преимущества: типобезопасность, поддержка множества фич GraphQL
  - Генерирует как модели, так и резолверы

### 3. Для Protocol Buffers:

- **protoc** с плагином Go:
  ```bash
  protoc --go_out=. --go_opt=paths=source_relative proto/*.proto
  ```
  - Высокая производительность сериализации/десериализации
  - Компактное бинарное представление
  - Возможность использования в gRPC

### 4. Для JSON Schema:

- **go-jsonschema**:
  ```bash
  go-jsonschema -p api -o api/models.gen.go schema.json
  ```
  - Генерация Go-структур из JSON Schema
  - Поддержка валидации

### Рекомендация:

1. **Для REST API**: Использовать OpenAPI/Swagger с oapi-codegen, особенно если API уже описан в формате OpenAPI 3.0
2. **Для GraphQL API**: Использовать gqlgen, который обеспечивает полную поддержку спецификации GraphQL
3. **Для внутренних API с высокими требованиями к производительности**: Использовать Protocol Buffers с gRPC

Выбор инструмента должен основываться на:
- Существующей документации API (если она уже в определенном формате)
- Требованиях к производительности
- Типе разрабатываемого API (REST, GraphQL, RPC)
- Необходимости в валидации входных данных

При интеграции автогенерации в проект рекомендуется:
1. Добавить генерацию в процесс сборки
2. Настроить линтеры для исключения проверки автогенерированного кода
3. Рассмотреть использование make-файла для управления процессом генерации

## Организация ошибок в проекте (deprecated)

### Предложение: У каждого сервиса или репозитория свои ошибки

**Аргументы "за":**
- Повышает инкапсуляцию и соблюдение принципа единственной ответственности
- Упрощает идентификацию источника ошибки
- Позволяет создавать специфические типы ошибок для конкретных компонентов
- Облегчает тестирование конкретных ошибок, возвращаемых компонентом

**Аргументы "против":**
- Может привести к дублированию кода для схожих ошибок
- Усложняет обработку ошибок на высоких уровнях (требуется больше проверок на конкретные типы)
- Увеличивает количество пакетов и усложняет структуру проекта
- Может затруднить внедрение централизованной обработки ошибок

**Предлагаемое решение:** Гибридный подход

1. **Общий пакет для определения базовых типов ошибок и функций:**
   ```go
   package errors

   type Error struct {
       Code    string
       Message string
       Cause   error
   }

   func (e *Error) Error() string {
       if e.Cause != nil {
           return fmt.Sprintf("%s: %s: %v", e.Code, e.Message, e.Cause)
       }
       return fmt.Sprintf("%s: %s", e.Code, e.Message)
   }

   func New(code, message string) *Error {
       return &Error{Code: code, Message: message}
   }

   func Wrap(code, message string, cause error) *Error {
       return &Error{Code: code, Message: message, Cause: cause}
   }

   func Is(err, target error) bool {
       // Реализация для проверки типов ошибок
   }
   ```

2. **Специфические ошибки компонентов определяются в их пакетах:**
   ```go
   package telegram

   import "github.com/example/budva43/errors"

   var (
       ErrRateLimit = errors.New("telegram.rate_limit", "Telegram API rate limit exceeded")
       ErrAuth      = errors.New("telegram.auth", "Authentication error")
       ErrNetwork   = errors.New("telegram.network", "Network error")
   )

   func NewRateLimitError(waitTime time.Duration) *errors.Error {
       e := *ErrRateLimit
       e.Message = fmt.Sprintf("Rate limit exceeded. Wait for %v", waitTime)
       return &e
   }
   ```

3. **Модули могут предоставлять функции-помощники для проверки типов ошибок:**
   ```go
   func IsRateLimitError(err error) bool {
       return errors.Is(err, ErrRateLimit)
   }

   func GetWaitTimeFromError(err error) (time.Duration, bool) {
       // Извлечение информации о времени ожидания из ошибки
   }
   ```

Этот подход сочетает централизованный механизм обработки ошибок с возможностью определения специфических ошибок для каждого компонента.

## Организация сервисов по модулям

Разнесение сервисов по модулям, подобно подходу с репозиториями, имеет ряд преимуществ:

**Предлагаемая структура:**
```
service/
├── message/
│   ├── service.go        # Интерфейс и основная реализация
│   ├── processor.go      # Компонент для обработки сообщений
│   ├── formatter.go      # Компонент для форматирования сообщений
│   └── service_test.go   # Тесты
│
├── forward/
│   ├── service.go        # Интерфейс и основная реализация
│   ├── rules.go          # Логика правил пересылки
│   └── service_test.go   # Тесты
│
└── ...
```

**Преимущества:**
1. **Улучшенная модульность**: Каждый сервис инкапсулирован в собственном модуле
2. **Снижение сложности файлов**: Разделение большого сервиса на логические компоненты
3. **Управление зависимостями**: Четкое определение зависимостей каждого сервиса
4. **Локализация изменений**: Изменения затрагивают только определенный модуль
5. **Улучшенная тестируемость**: Возможность создания специфических тестовых утилит для модуля

**Потенциальные недостатки:**
1. **Усложнение структуры проекта**: Увеличение количества директорий и файлов
2. **Возможное дублирование кода**: Без должного внимания может возникнуть дублирование
3. **Риск излишней фрагментации**: Слишком мелкая декомпозиция может усложнить понимание

**Вывод:** Разнесение сервисов по модулям является хорошей практикой, которая повышает модульность и гибкость кода при условии соблюдения баланса в уровне декомпозиции.
